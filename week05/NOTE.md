
# CSS computing
把 CSS 属性应用到匹配的选择器上去的过程。发生在 DOM 构建的时候。
需要对 CSS 进行词法语法分析。用 css 包, which is a css parser.
CSS 代码 => AST 抽象语法树
1. 收集 CSS 规则
2. 添加调用，在合适的时机应用 CSS 规则
  * "合适的时机"：当 DOM 树构建到 startTag 步骤时，已经可以判断可以匹配哪些 CSS 规则了。即创建一个元素后，立即计算 CSS
  * 理论上，当分析一个元素时，所以 CSS 规则已经收集完毕
  * 真实浏览器中，可能遇到写在 body 里的 style 标签，需要重新计算 CSS。我们忽略这种情况。 
3. 获取父元素序列。（今天的？？？选择器大都是和父元素相关的）// 当代的？例子中的？
  * computeCSS 函数中，必须知道当前元素的所有父元素，才能判断它是否与CSS规则匹配
  * 从上一步骤的 stack 里，可以获取当前元素的所有父元素
  * 关于reverse，举例：子孙选择器 div div #myid{} 前两个 div 到底要跟哪两个元素匹配，是不确定的。而最后一个一定是和当前元素匹配。
    * 所以在实现 CSS 的匹配规则时，一定是先检查最后一个选择器 是否匹配当前元素。所以计算父元素的顺序是从内向外。
4. 处理选择器和元素的匹配
  * 选择器的层级结构：选择器列表 > 复杂选择器(根据亲代关系选择元素，由空格分隔的一系列复合选择器构成) > 复合选择器（是对一个元素的属性特征的判断，由紧连着的简单选择器构成） > 简单选择器
  * 我们假设复杂选择器仅包含简单选择器，不处理复合的情况了
  * 用循环匹配元素与选择器
5. 计算选择器与元素匹配
  * 根据选择器的类型和元素属性计算
  * 仅实现了三种基本选择器，略过了符合选择器
  * 可选：实现复合选择器，支持带空格的class选择器
6. 一旦匹配，就应用选择器到元素上，形成 computedStyle
7. 选择器的优先级 specificity 计算规则
  * 四元组 [inline, id, class, tagname]
  * 高位比较原则
  CSS 覆盖规则：specificity & 后来优先


# layout 布局/排版
目的是得到一颗带位置的 DOM 树
1. 三代排版技术：
  * 正常流 position display float
  * flex 以此为例实现
  * grid
  * CSS houdini 第四代？

2. 主轴：排布时的延伸方向 Main axis
   交叉轴： 跟主轴垂直的方向 Cross axis
   这种抽象可以在写代码时减少大量的 if else

3. 时机：flex 布局需要知道子元素，所以子元素一定发生在结束标签之前（这是人话？？？）

4. 收集元素进行内
  * 分行：根据主轴尺寸，把元素分进行内；若设置了 no-wrap，则强行分配进第一行

5. 计算主轴方向的尺寸（以 row 为例，算出 width left right）
  * 把主轴上的剩余空间，按 flex items 各自的设置，按比例分配给 flex 元素
  * 若剩余空间为负数（no-wrap 时），将所有 flex 元素的宽度置位 0，等比例压缩剩余的元素（web 标准的规定）

6. 计算交叉轴尺寸（以 row 为例，算 height top bottom）(这六者确定了，元素的位置就完全确定了。其实确定了4个，就能计算出剩下的两个)
  * 根据每行最大元素计算行高
  * 根据行高 flex-align 和 item-align，确定元素具体位置


# 绘制
1. 绘制依赖图形环境，用了 images
2. 绘制在 viewport 上进行
3. 与绘制有关的属性：background-color, border, background-image etc.
  * gradient 需要 webGL 来做，images 做不出
4. 递归调用子元素的绘制方法，可以完成 DOM 树的绘制
5. 忽略一些不需要绘制的节点 ？
6. 实际的浏览器中，文字绘制是难点，依赖字体库，把字体变成图片再渲染。忽略。
7. 实际浏览器中，还会对图层进行 compositing，忽略。
